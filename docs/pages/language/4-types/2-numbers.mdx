import { Callout } from 'nextra/components'

# Numbers
Blink has support for all buffer implemented number types, signed integers, unsigned integers, floating points, and more.

Number types start with a prefix like: `u`, `i` or `f`, and are followed by the number of bits used to represent the number.
The number of bits also corresponds to the cost of sending a particular number type over the network.

## Unsigned Integers
Unsigned integers are whole numbers, greater than or equal to zero.<br/>

|Name|Size|Min|Max|
|----|----|---|---|
|`u8`|`1 byte`|`0`|`255`|
|`u16`|`2 bytes`|`0`|`65,535`|
|`u32`|`4 bytes`|`0`|`4,294,967,295`|

## Signed Integers
Signed integers, unlike unsigned integers, can represent both positive and negative whole numbers.

|Name|Size|Min|Max|
|----|----|---|---|
|`i8`|`1 byte`|`-128`|`127`|
|`i16`|`2 bytes`|`-32,768`|`32,767`|
|`i32`|`4 bytes`|`-2,147,483,648`|`2,147,483,647`|

## Floating points
Floating points represent numbers with a decimal point.

Unlike integers, the bit size of a floating point does not correlate to a hard range limit. 
Instead it determines it's numerical accuracy (or precision).
For this reason, the table below lists the maximum accurately representable integer by each floating point type.

<Callout type="info">
    Internally Luau stores its numbers as a `f64`.
</Callout>

<Callout type="info">
    The f16 type isn't natively supported by the buffer library, making it slower to read and write than other types.
</Callout>

|Name|Size|Min|Max|
|----|----|---|---|
|`f16`|`2 bytes`|`-2048`|`2048`|
|`f32`|`4 bytes`|`-16,777,216`|`16,777,216`|
|`f64`|`8 bytes`|`-9,007,199,254,740,992`|`9,007,199,254,740,992`|

## Bounding Numbers

The values of numbers can be bounded by placing [a range](./1-ranges.mdx) within parenthesis after the type.<br/>
An example health `u8` number type from `0` to `100` can be written like:
```ts copy
u8(0..100)
u8(..100)
```
## Example Usage
```ts copy
type Health = u8(0..100)
type UserId = f64
```