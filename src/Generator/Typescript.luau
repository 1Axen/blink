--!strict

local Parser = require("../Parser")
local Settings = require("../Settings")

local Util = require("./Util")
local Blocks = require("./Blocks")
local Prefabs = require("./Prefabs")

local Builder = require("../Modules/Builder")

type Type = Parser.TypeNode
type Scope = Parser.Scope
type Context = "Client" | "Server" | "Shared"
type AbstractSyntaxTree = Parser.Body

type State = {
    Scope: Scope,
    Indent: number,
    Casing: Settings.Cases,
    Builder: Builder.Builder,
    Context: Context,
    Options: Parser.Options,
}

local TESTING_HEADER = "type Instance = number\ntype Player = number\ntype CFrame = number\ntype Vector3 = number\ntype Color3 = number\ntype Sound = number\ntype buffer = number\n"
local VERSION_HEADER = `// File generated by Blink v{_G.VERSION or "0.0.0"} (https://github.com/1Axen/Blink)\n// This file is not meant to be edited\n`

local Generators = {}
local Primitives = Prefabs.Primitives

local function GetPrefix(Indent: number): string
    return Indent == 0 and "declare " or ""
end

local function IsValidIdentifier(Identifier: string): boolean
	return Identifier:match("%a%w*") == Identifier
end

local function FormatKey(Key: string): string
	if IsValidIdentifier(Key) then
		return Key
	end
	return `["{Key}"]`
end

local function GetTypescriptType(State: State, Declaration: Type): (string, string)
    local Type = ""
    local Values = ""

    if Declaration.Type == "Primitive" then
		local Tokens = (Declaration :: Parser.Primitive).Tokens
		local Primitive = Primitives[Tokens.Primitive.Value]
		if type(Primitive.Type) == "function" then
			Type = Primitive.Type(Declaration :: Parser.Primitive)
		else
			Type = Primitive.Type
		end

		if Type == "any" then
			Type = "unknown"
		end
	elseif Declaration.Type == "Set" then
		local Value = (Declaration :: Parser.Set).Value
		local Entries: {string} = {}

		for _, Flag in Value.Values do
			table.insert(Entries, `{FormatKey(Flag)}: boolean,`)
		end

		Type = `\{{table.concat(Entries)}\}`
	elseif Declaration.Type == "Enum" then
		local Value = (Declaration :: Parser.Enum).Value
		Type = Util.GenerateEnumLiterals(Value.Values)
	elseif Declaration.Type == "TagEnum" then
		local Value = (Declaration :: Parser.TagEnum).Value
		local Literals = {}

		for Index, Variant in Value.Values do
			local TagField = `{Value.Tag}: "{Variant.Name}"`
			local ValueType = GetTypescriptType(State, Variant)
			table.insert(Literals, `\{ {TagField},{string.sub(ValueType, 2)}`)
		end

		Type = table.concat(Literals, " | ")
	elseif Declaration.Type == "Map" then
		local MapValue = (Declaration :: Parser.Map).Value
		local Key = GetTypescriptType(State, MapValue.Values[1])
		local Value = GetTypescriptType(State, MapValue.Values[2])
		Type = `Map<{Key}, {Value}>`
	elseif Declaration.Type == "Struct" then
		local Value = Declaration.Value
		local Fields = {}
		
		for _, Field in Value.Values do
			local Name = Field.Name
			local FieldType = GetTypescriptType(State, Field)
			table.insert(Fields, `{FormatKey(Name)}: {FieldType}`)
		end

		Type = `\{ {table.concat(Fields, ", ")}\ }`
	elseif Declaration.Type == "Generic" then
		Type = `{Declaration.Value.Generic}`
	elseif Declaration.Type == "Tuple" then
		local Value = (Declaration :: Parser.Tuple).Value
		local TupleValues = Value.Values

		local Types = {}
		local Variables = {} 
		local VariableTypes = {}

		for Index, TupleValue in TupleValues do
			local Variable = `Value{Index}`
			local ValueType = GetTypescriptType(State, TupleValue)
			table.insert(Types, ValueType)
			table.insert(Variables, Variable)
			table.insert(VariableTypes, `{Variable}: {ValueType}`)
		end

		Type = `{table.concat(Types, ", ")}`
        Values = table.concat(VariableTypes, ", ")
	elseif Declaration.Type == "Array" then
		local Value = Declaration.Value
		Type = `{GetTypescriptType(State, Value.Of)}[]`
	elseif Declaration.Type == "Optional" then
		local Value = Declaration.Value
		Type = `{GetTypescriptType(State, Value.Of)} | undefined`
	end

	local Value = Declaration.Value
	if Value.Parameters then
		local Parameters = {}

		--> Generate luau types for parameters
		for Index, Parameter in Value.Parameters do
			local ParameterType = GetTypescriptType(State, Parameter)
			table.insert(Parameters, ParameterType)
		end

		--> Wrap in chevrons
		Type = `{Type}<{table.concat(Parameters, ",")}>`
	end

    --> Generalized type generation, works for everything except tuples
	if Declaration.Type ~= "Tuple" then
		Values = `Value: {Type}`
	else
		Type = `LuaTuple<[{Type}]>`
	end

	return Type, Values
end

function Generators.Type(State: State, Type: Type)
	local Name = Type.Name
    local Value = Type.Value

    local Indent = State.Indent
    local StringBuilder = State.Builder
    
    local TypescriptType = GetTypescriptType(State, Type)

    local Generics = ""
	if Value.Generics then
		local Types = {}
		for _, Generic in Value.Generics.List do
			table.insert(Types, Generic)
		end

		Generics = `<{table.concat(Types, ",")}>`
	end

    StringBuilder.Push(`type {Name}{Generics} = {TypescriptType}`, 0, Indent)
end

function Generators.Export(State: State, Type: Type)
	local Name = Type.Name

    local Indent = State.Indent
    local Casing = State.Casing
    local StringBuilder = State.Builder

    local Types, Values = GetTypescriptType(State, Type)
    StringBuilder.Push(`{GetPrefix(Indent)}const {Name}: \{`, 0, Indent)
    StringBuilder.Push(`{Casing.Read}: (Buffer: buffer) => {Types}`, 0, Indent + 1)
    StringBuilder.Push(`{Casing.Write}: ({Values}) => buffer`, 0, Indent + 1)
    StringBuilder.Push(`\}`, 0, Indent)
end

function Generators.Function(State: State, Function: Parser.Function)
	local Name = Function.Name
    local Value = Function.Value

    local Indent = State.Indent
    local Casing = State.Casing
    local StringBuilder = State.Builder

    local _, Values = "void", "Value: void"
	if Value.Data then
		_, Values = GetTypescriptType(State, Value.Data)
	end

	local ReturnTypes = "void"
	if Value.Return then
		ReturnTypes = GetTypescriptType(State, Value.Return)
	end

    StringBuilder.Push(`export {GetPrefix(Indent)}const {Name}: \{`, 0, Indent)

    if State.Context == "Server" then
        StringBuilder.Push(`{Casing.On}: (Listener: (Player: Player, {Values}) => {ReturnTypes}) => void`, 0, Indent + 1)
    else
		if Value.Yield == "Promise" then
			ReturnTypes = `Promise<{ReturnTypes}>`
		end
		
        StringBuilder.Push(`{Casing.Invoke}: ({Values}) => {ReturnTypes}`, 0, Indent + 1)
    end

    StringBuilder.Push(`\}`, 0, Indent)
end

function Generators.Event(State: State, Event: Parser.Event)
	local Name = Event.Name
    local Value = Event.Value

    local Indent = State.Indent
    local Casing = State.Casing
    local StringBuilder = State.Builder

	local IsPolling = if Value.Poll ~= nil then Value.Poll else State.Options.UsePolling

    local _, Values = "", "Value: void"
	if Value.Data then
		_, Values = GetTypescriptType(State, Value.Data)
	end

    local ListenerValues = Values
    if Value.From == "Client" then
        ListenerValues = `Player: Player, {Values}`
    end

    if IsPolling then
        ListenerValues = `Index: number, {ListenerValues}`
        ListenerValues = `LuaTuple<[{ListenerValues}]>`
    end

    StringBuilder.Push(`export {GetPrefix(Indent)}const {Name}: \{`, 0, Indent)

    if Value.From == State.Context then
        if Value.From == "Server" then
            StringBuilder.Push(`{Casing.Fire}: (Player: Player, {Values}) => void`, 0, Indent + 1)
            StringBuilder.Push(`{Casing.FireAll}: ({Values}) => void`, 0, Indent + 1)
            StringBuilder.Push(`{Casing.FireExcept}: (Except: Player, {Values}) => void`, 0, Indent + 1)
            StringBuilder.Push(`{Casing.FireList}: (List: Player[], {Values}) => void`, 0, Indent + 1)
        else
            StringBuilder.Push(`{Casing.Fire}: ({Values}) => void`, 0, Indent + 1)
        end
    elseif IsPolling then
        StringBuilder.Push(`{Casing.Iter}: () => IterableFunction<{ListenerValues}>`, 0, Indent + 1)
    else
        StringBuilder.Push(`{Casing.On}: (Listener: ({ListenerValues}) => void) => (() => void)`, 0, Indent + 1)
    end

    StringBuilder.Push(`\}`, 0, Indent)
end

function Generators.Scope(State: State, Scope: Parser.ScopeNode)
	local Name = Scope.Name
    local Value = Scope.Value

    local Parent = State.Scope
    local Indent = State.Indent
    local StringBuilder = State.Builder

    State.Indent += 1
	State.Scope = Value.Scope

	StringBuilder.Push(`export {GetPrefix(Indent)}namespace {Name} \{`, 0, Indent)
	Generators.Tree(State, Value.Values)
	StringBuilder.Push(`}`, 0, Indent)

    State.Indent -= 1
	State.Scope = Parent
end

function Generators.Tree(State: State, Tree: {Parser.Declaration})
    for Index, Declaration in Tree do
		if Declaration.Type == "Scope" then
			Generators.Scope(State, Declaration :: Parser.ScopeNode)
		elseif Declaration.Type == "Event" then
			Generators.Event(State, Declaration :: Parser.Event)
		elseif Declaration.Type == "Function" then
			Generators.Function(State, Declaration :: Parser.Function)
		else
			if Declaration.Value.Export then
				Generators.Export(State, Declaration :: Type)
			end

			Generators.Type(State, Declaration :: Type)
		end
	end
end

return function(FileContext: Context, AbstractSyntaxTree: AbstractSyntaxTree): string
    local Options = AbstractSyntaxTree.Value.Options
    local Casing = Settings.GetCasing(Options.Casing or "Pascal" :: any)
    local StringBuilder = Builder.new()

    StringBuilder.Push(VERSION_HEADER)
    StringBuilder.Push(`export declare const {Casing.StepReplication}: () => void`)

    if _G.VERSION == nil then
        StringBuilder.Push(TESTING_HEADER)
    end

    local State: State = {
        Scope = nil :: any,
        Indent = 0,
        Casing = Casing,
        Context = FileContext,
        Options = Options,
        Builder = StringBuilder,
    }

    Generators.Tree(State, AbstractSyntaxTree.Value.Declarations)

    return table.concat(StringBuilder.DumpLines())
end
