--!native
--!optimize 2
--!strict

local Parser = require("../Parser")
local Settings = require("../Settings")

local Table = require("../Modules/Table")
local Builder = require("../Modules/Builder")

local Util = require("./Util")
local Blocks = require("./Blocks")
local Prefabs = require("./Prefabs")
local GenerateTypescript = require("./Typescript")

local Sources = {
	Base = require("../Templates/Base"),
	Shared = {"", ""},
	Client = string.split(require("../Templates/Client"), "-- SPLIT --"),
	Server = string.split(require("../Templates/Server"), "-- SPLIT --"),
}

local EVENTS_TYPE = "BLINK_EVENTS_SYMBOL"
local DIRECTIVES = {"--!strict\n", "--!native\n", "--!optimize 2\n", "--!nolint LocalShadow\n", "--#selene: allow(shadowing)\n"}
local VERSION_HEADER = {`-- File generated by Blink v{_G.VERSION or "0.0.0"} (https://github.com/1Axen/Blink)\n-- This file is not meant to be edited\n\n`}

local EVENT_BODY = {
	"RecieveCursor = 0\n",
	"RecieveBuffer = Buffer\n",
	"RecieveInstances = Instances\n",
	"RecieveInstanceCursor = 0\n",
	"local Size = buffer.len(RecieveBuffer)\n"
}

local RELIABLE_BODY = {
	Header = "local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances",
	Body = {
		"Load(PlayersMap[Player])\n",
		"local Position = Allocate(Size)\n",
		"buffer.copy(SendBuffer, Position, Buffer, 0, Size)\n",
		"table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)\n",
		"PlayersMap[Player] = Save()\n",
	}
}

local UNRELIABLE_BODY = {
	"local Buffer = buffer.create(SendCursor)\n",
	"buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)\n"
}

local DEBUG_GLOBALS = {
	"local og_typeof = typeof\n",
	"local typeof = function(a: any)\n",
	"\tif type(a) == \"table\" then\n",
	"\t\treturn a.__typeof or \"table\"\n",
	"\tend\n",
	"\treturn og_typeof(a)\n",
	"end\n",
	"local task = require(\"@lune/task\")\n",
	"local game = _G.%s.game\n",
	"local Color3 = _G.%s.Color3\n",
}

local IGNORED_TYPES_IN_SHARED = {
	Event = true,
	Function = true
}

type Type = Parser.TypeNode
type Scope = Parser.Scope
type Context = "Client" | "Server" | "Shared"
type NumberRange = {Min: number, Max: number}

local Scope: Scope;
local Context: Context;
local Casing: Settings.Cases;
local Noop: Builder.Builder;
local Events: Builder.Builder;
local UserTypes: Builder.Builder;
local LuauTypes: Builder.Builder;
local Reliables: Blocks.Block;
local Unreliables: Blocks.Block;
local Return: Builder.Builder;
local Options: Parser.Options;

local Generators = {}
local Declarations = {}

local Channels: { [string]: { Count: number, Listening: boolean } } = {
	Reliable = { Count = 0, Listening = false },
	Unreliable = { Count = 0, Listening = false },
}

local Types = Prefabs.Types
local Primitives = Prefabs.Primitives
local Structures = Prefabs.Structures

local function IsValidIdentifier(Identifier: string): boolean
	return Identifier:match("%a%w*") == Identifier
end

local function FormatKey(Key: string): string
	if not IsValidIdentifier(Key) then
		return `["{Key}"]`
	end
	return Key
end

local function FormatIndex(Index: string): string
	if not IsValidIdentifier(Index) then
		return `["{Index}"]`
	end
	return `.{Index}`
end

--> Declaration functions

function Declarations.Primitive(Declaration: Parser.Primitive, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Tokens = Declaration.Tokens
	local Primitive = Tokens.Primitive.Value
    local Generator = Primitives[Primitive]
    Generator.Generate(Declaration, Variable, Read, Write, Options.WriteValidations)
end

function Declarations.Set(Declaration: Parser.Set, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Flags = Value.Values

	local BitsType = Prefabs.GetTypeToUseByBits(math.min(#Flags, 32))
	local IsOverBit32Limit = #Flags > 32

	--> Read body
	if not IsOverBit32Limit then
		BitsType.Read("SET_BITS", Read)
	end

	Read:Line(`{Read:Declare(Variable)} = \{`)

	for Index, Flag in Flags do
		Read:EmptyDeclare(Flag)

		if IsOverBit32Limit then
			Prefabs.Types.boolean.Read(Flag, Read)
			Read:Character(",")
		else
			Read:Line(`{FormatKey(Flag)} = (bit32.extract(SET_BITS, {Index - 1}) == 1),`, Read.Indent + 1)
		end
	end

	Read:Line("}")

	--> Write body
	if not IsOverBit32Limit then
		Write:Line("local SET_BITS = 0")
	end

	for Index, Flag in Flags do
		if IsOverBit32Limit then
			Prefabs.Types.boolean.Write(`{Variable}{FormatIndex(Flag)}`, Write)
		else
			Write:Line(`SET_BITS = bit32.bor(SET_BITS, bit32.lshift(({Variable}{FormatIndex(Flag)}) and 1 or 0, {Index - 1}))`)
		end
	end

	if not IsOverBit32Limit then
		BitsType.Write("SET_BITS", Write)
	end
end

function Declarations.Enum(Declaration: Parser.Enum, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Enums = Value.Values
	local Literal = Util.GenerateEnumLiterals(Enums)
	Literal = string.gsub(Literal, "|", "or")

	--> Read body
	Read:Line(`{Read:Declare(Variable)} = true :: any`)
	Types.u8.Read(`Index`, Read)
	Read = Read:Compare("Index", "0", "Equals")
		for Index, EnumItem in Enums do
			if Index > 1 then
				Read = Read:Branch("Conditional", "Index", `{Index - 1}`, "Equals")
			end

			Read:Line(`{Variable} = "{EnumItem}"`)
		end
	Read:Branch("Default")
		:Line(`error(\`Unexpected enum: \{Index\}\`)`)
	:End()

	--> Write body
	local Allocation = Write:Allocate(1)
		for Index, EnumItem in Enums do
			if Index == 1 then
				Write = Write:Compare(Variable, `"{EnumItem}"`, "Equals")
			else
				Write = Write:Branch("Conditional", Variable, `"{EnumItem}"`, "Equals")
			end

			Write:Line(`buffer.writeu8(SendBuffer, {Allocation}, {Index - 1})`)
		end
	Write:Branch("Default")
		:Line(`error(\`Unexpected enum: \{{Variable}\}, expected one of {Literal}.\`)`)
	:End()
end

function Declarations.Map(Declaration: Parser.Map, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local MapValue = Declaration.Value
	local Key = MapValue.Values[1]
	local Value = MapValue.Values[2]

	local KeyVariable = `Key_{Read.Indent}`
	local ElementVariable = `Element_{Write.Indent}`
	local ElementsVariable = `Elements_{Write.Indent}`
	local ElementsAllocation = Write:Allocate(2)

	Read:Line(`{Read:Declare(Variable)} = \{\}`)
	Write:Line(`local {ElementsVariable} = 0`)
	Types.u16.Read(ElementsVariable, Read)

	local ReadLoop = Read:Loop("_ = 1", ElementsVariable)
	local WriteLoop = Write:Iterator(KeyVariable, ElementVariable, Variable)

	--> Maps are unsafe
	ReadLoop:DisableOperationOptimisations()
	WriteLoop:DisableOperationOptimisations()

	--ReadLoop:Line(`local Key: {KeyType}, Element: {ValueType};`)
	WriteLoop:Line(`{ElementsVariable} += 1`)
	Generators.UserType(Key :: Type, ReadLoop, WriteLoop, KeyVariable)
	Generators.UserType(Value :: Type, ReadLoop, WriteLoop, ElementVariable)
	ReadLoop:Line(`{Variable}[{KeyVariable}] = {ElementVariable}`)

	WriteLoop:End()
	ReadLoop:End()

	Write:Line(`buffer.writeu16(SendBuffer, {ElementsAllocation}, {ElementsVariable})`)
end

function Declarations.Struct(Declaration: Parser.Struct, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	Read:Line(`{Read:Declare(Variable)} = \{\} :: any`)

	for _, Field in Value.Values do
		local Name = Field.Name
		local FieldVariable = `{Variable}{FormatIndex(Name)}`
		Generators.UserType(Field :: Type, Read, Write, FieldVariable)
	end
end

function Declarations.Tuple(Declaration: Parser.Tuple, Read: Blocks.Block, Write: Blocks.Block)
	for Index, Value in Declaration.Value.Values do
		local Variable = `Value{Index}`
		Generators.UserType(Value :: Type, Read, Write, Variable)
	end
end

function Declarations.TagEnum(Declaration: Parser.TagEnum, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Values = Value.Values

	--> Body
	local Tag = Value.Tag
	local Header = `"{Values[1].Name}"`
	local TagIndex = `{Variable}{FormatIndex(Tag)}`

	Types.u8.Read(`Tag`, Read)
	Read:Line(`{Read:Declare(Variable)} = true :: any`)

	local Allocation = Write:Allocate(1)

	Read = Read:Compare("Tag", "0", "Equals")
	Write = Write:Compare(TagIndex, Header, "Equals")

	for Index, Variant in Values do
		local Name = `"{Variant.Name}"` 
		if Index > 1 then
			Read = Read:Branch("Conditional", "Tag", tostring(Index - 1), "Equals")
			Write = Write:Branch("Conditional", TagIndex, Name, "Equals")
		end

		Write:_lineFront(`buffer.writeu8(SendBuffer, {Allocation}, {Index - 1})`)
		Write:Advance(1)

		Generators.UserType(Variant, Read, Write, Variable)
		Read:Line(`{TagIndex} = {Name}`)
	end

	Read:Branch("Default")
		:Line(`error(\`Unexpected variant: \{Tag\}\`)`)
	:End()
	
	Write:Branch("Default")
		:Line(`error(\`Unexpected variant: \{{TagIndex}\}\`)`)
	:End()
end

function Declarations.Event(Declaration: Parser.Event)
	local Value = Declaration.Value

	local Identifier = `EVENT_{Declaration.Name}`
	local Reliability = Value.Type

	local IsReliable = (Reliability == "Reliable")
	local IsUnreliable = (Reliability == "Unreliable")
	local IsPolling = if Value.Poll ~= nil then Value.Poll else Options.UsePolling
	local IsSameContext = Value.From == Context

	local Block = IsUnreliable and Unreliables or Reliables
	local Channel = IsUnreliable and Channels.Unreliable or Channels.Reliable

	local Index = Channel.Count
	local Queue = `Queue.{Reliability}[{Index}]`
	local Connection = `Events.{Reliability}[{Index}]`

	--> Data body
	local Types, Values, Arguments, _ = "nil", "Value: nil", "Value", nil
	local Read, Write = Generators.Event(Value.Data, Index, Identifier)

	if Value.Data then
		Types, Values, _, Arguments = Generators.LuauType(Value.Data :: Type, true)
	end

	if IsSameContext then
		UserTypes.PushLines(Write, 1, 0)
	else
		UserTypes.PushLines(Read, 1, 0)
	end

	--> Return body
	local Body = Builder.new()
	local Indent = Util.GetScopeIndent(Scope)
	local WriteEvent = `{Util.GetPath(Identifier, true, Scope)}({Arguments})`

	Body.Push(`{Declaration.Name} = \{`, 0, Indent)
	Noop.Push(`{Declaration.Name} = \{`, 0, Indent)

	if Value.From ~= Context and IsPolling ~= true then
		local IsSync = (Value.Call == "SingleSync" or Value.Call == "ManySync")
		local IsSingle = (Value.Call == "SingleSync" or Value.Call == "SingleAsync")

		--> Create queue and event branch
		if not IsSingle then
			Events.Push(`{Connection} = \{}`)
		end

		Events.Push(`{Queue} = table.create(256)`)
		Block = (Channel.Listening == false)
			and Block:Compare("Index", Index, "Equals")
			or Block:Branch("Conditional", "Index", Index, "Equals")
	
		--> Update event block to branch block
		if IsUnreliable then
			Unreliables = Block
		else
			Reliables = Block
		end
		
		--> Update channel status
		Channel.Listening = true

		--> Event recieve body
		local Listener: Blocks.Block;
		local ContextArguments = `Listener: ({Context == "Server" and "Player: Player, " or ""}{Values}) -> ()`
		local ListenerArguments = `{Context == "Server" and "Player, " or ""}{Arguments}`
		
		local CallManyListenerFunction = IsSingle and `Listener({ListenerArguments})` or `task.spawn(Listener, {ListenerArguments})`
		local CallSingleListenerFunction = IsSync and `{Connection}({ListenerArguments})` or `task.spawn({Connection}, {ListenerArguments})`

		Block:Line(`local {Values} = {Util.GetPath(Identifier, false, Scope)}()`)

		local Disconnect = Blocks.Function("", "", "()")
			:Line(IsSingle and `{Connection} = nil` or `table.remove({Connection}, table.find({Connection}, Listener))`)
			:End()
		:Wrap("return ", "")

		if IsReliable then
			local ListenerBound: Blocks.Block;
			if IsSingle then
				ListenerBound = Block:Compare(Connection, "nil", "Not")
					:Line(CallSingleListenerFunction)
			else
				ListenerBound = Block:Compare(`#{Connection}`, "0", "Greater")
					:Iterator("_", "Listener", Connection)
						:Line(CallManyListenerFunction)
					:End()
			end
				
			ListenerBound:Branch("Default")
				:Compare(`#{Queue}`, "256", "Greater")
					:Line(`warn("[Blink]: Event queue of \\"{Declaration.Name}\\" exceeded 256, did you forget to implement a listener?")`)
				:End()
				:Line(`table.insert({Queue}, \{{ListenerArguments}\} :: \{any\})`)
			:End()

			Listener = Blocks.Function(Casing.On, ContextArguments, `() -> ()`, true)
				:Line(IsSingle and `{Connection} = Listener` or `table.insert({Connection}, Listener)`)
				:Iterator("Index", "Arguments", Queue)
					:Line(IsSync and `Listener(table.unpack(Arguments))` or `task.spawn(Listener, table.unpack(Arguments))`)
				:End()
				:Line(`{Queue} = \{}`)
				:Lines(Disconnect.Content, 1)
			:End()
		else
			if IsSingle then
				Block:Compare(Connection, "nil", "Not")
					:Line(CallSingleListenerFunction)
				:End()
			else
				Block:Compare(Connection, "nil", "Not")
					:Iterator("_", "Listener", Connection)
						:Line(CallManyListenerFunction)
					:End()
				:End()
			end

			Listener = Blocks.Function(Casing.On, ContextArguments, `() -> ()`, true)
				:Line(IsSingle and `{Connection} = Listener` or `table.insert({Connection}, Listener)`)
				:Lines(Disconnect.Content, 1)
			:End()
		end

		Noop.Push(`{Casing.On} = NOOP`, 0, Indent + 1)
		Body.PushLines(Listener.Content, 0, Indent + 1)
	elseif Value.From ~= Context and IsPolling then
		Events.Push(`{Queue} = CreateQueue()`)
		Block = (Channel.Listening == false)
			and Block:Compare("Index", Index, "Equals")
			or Block:Branch("Conditional", "Index", Index, "Equals")

		if IsUnreliable then
			Unreliables = Block
		else
			Reliables = Block
		end

		Channel.Listening = true
		Block:Line(`Push({Queue}, table.pack({Context == "Server" and "Player, " or ""}{Util.GetPath(Identifier, false, Scope)}()))`)

		local IterTypes = `number, {Context == "Server" and "Player, " or ""}{Types}`
		
		local Next = Blocks.Function("", "", `({IterTypes})`)
			:Line("index += 1")
			:Line("local arguments = Pop(queue)")
			:Compare("arguments", "nil", "Not")
				:Return("index, unpack(arguments, 1, arguments.n)")
			:End()
			:Return("")
			:End()
		:Wrap("return ", "")

		local Deprecated = Blocks.Function(Casing.Next, "", `() -> ({IterTypes})`, true)
			:Line(`local index = 0`)
			:Line(`local queue = {Queue}`)
			:Lines(Next.Content, 1)
		:End()

		local Iter = Blocks.Function(Casing.Iter, "", `() -> ({IterTypes})`, true)
			:Line(`local index = 0`)
			:Line(`local queue = {Queue}`)
			:Lines(Next.Content, 1)
		:End():Wrap("", ",")

		Noop.Push(`{Casing.Iter} = NOOP,`, 0, Indent + 1)
		Noop.Push(`{Casing.Next} = NOOP`, 0, Indent + 1)

		Body.PushLines(Iter.Content, 0, Indent + 1)
		Body.Push("--- @deprecated v0.14.1 -- Use `Iter` instead.", 0, Indent + 1)
		Body.PushLines(Deprecated.Content, 0, Indent + 1)
	elseif Context == "Client" then
		local Fire = Blocks.Function(Casing.Fire, Values, "()", true)
			if IsReliable then
				Fire:Line(WriteEvent)
			else
				Fire:Line(`local Previous = Save()`)
				Fire:Line(`Load()`)
				Fire:Line(WriteEvent)
				Fire:Line("local Buffer = buffer.create(SendCursor)")
				Fire:Line("buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)")
				Fire:Line("Unreliable:FireServer(Buffer, SendInstances)")
				Fire:Line("Load(Previous)")
			end
		Fire:End()

		Noop.Push(`{Casing.Fire} = NOOP`, 0, Indent + 1)
		Body.PushLines(Fire.Content, 0, Indent + 1)
	else
		local Fire = Blocks.Function(Casing.Fire, `Player: Player, {Values}`, "()", true)
			if IsReliable then
				Fire:Line("Load(PlayersMap[Player])")
				Fire:Line(WriteEvent)
				Fire:Line("PlayersMap[Player] = Save()")
			else
				Fire:Line("Load()")
				Fire:Line(WriteEvent)
				Fire:Lines(UNRELIABLE_BODY, 1)
				Fire:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
			end
		Fire:End()

		local FireAll = Blocks.Function(Casing.FireAll, Values, "()", true)
			if IsReliable then
				FireAll:Line("Load()")
				FireAll:Line(WriteEvent)
				FireAll:Line(RELIABLE_BODY.Header)
				FireAll:Iterator("_", "Player", "Players:GetPlayers()")
					:Lines(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireAll:Line("Load()")
				FireAll:Line(WriteEvent)
				FireAll:Lines(UNRELIABLE_BODY, 1)
				FireAll:Line("Unreliable:FireAllClients(Buffer, SendInstances)")
			end
		FireAll:End()

		local FireList = Blocks.Function(Casing.FireList, `List: \{Player\}, {Values}`, "()", true)
			if IsReliable then
				FireList:Line("Load()")
				FireList:Line(WriteEvent)
				FireList:Line(RELIABLE_BODY.Header)
				FireList:Iterator("_", "Player", "List")
					:Lines(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireList:Line("Load()")
				FireList:Line(WriteEvent)
				FireList:Lines(UNRELIABLE_BODY, 1)
				FireList:Iterator("_", "Player", "List")
					:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
				:End()
			end
		FireList:End()

		local FireExcept = Blocks.Function(Casing.FireExcept, `Except: Player, {Values}`, "()", true)
			if IsReliable then
				FireExcept:Line("Load()")
				FireExcept:Line(WriteEvent)
				FireExcept:Line(RELIABLE_BODY.Header)
				FireExcept:Iterator("_", "Player", "Players:GetPlayers()")
					:Compare("Player", "Except", "Equals")
						:Line("continue")
					:End()
					:Lines(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireExcept:Line("Load()")
				FireExcept:Line(WriteEvent)
				FireExcept:Lines(UNRELIABLE_BODY, 1)
				FireExcept:Iterator("_", "Player", "Players:GetPlayers()")
					:Compare("Player", "Except", "Equals")
						:Line("continue")
					:End()
					:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
				:End()
			end
		FireExcept:End()

		Noop.PushLines({
			`{Casing.Fire} = NOOP,\n`,
			`{Casing.FireAll} = NOOP,\n`,
			`{Casing.FireList} = NOOP,\n`,
			`{Casing.FireExcept} = NOOP\n`,
		}, 0, Indent + 1)

		Body.PushLines(Fire:Wrap("", ",").Content, 0, Indent + 1)
		Body.PushLines(FireAll:Wrap("", ",").Content, 0, Indent + 1)
		Body.PushLines(FireList:Wrap("", ",").Content, 0, Indent + 1)
		Body.PushLines(FireExcept:Wrap("", ",").Content, 0, Indent + 1)
	end

	Channel.Count += 1

	Body.Push(`\},`, 0, Indent)
	Noop.Push(`\},`, 0, Indent)
	Return.PushLines(Body.DumpLines(), 0)
end

function Declarations.Function(Declaration: Parser.Function)
	local Name = Declaration.Name
	local Value = Declaration.Value

	local DataIdentifier = `FUNCTION_DATA_{Name}`
	local ReturnIdentifier = `FUNCTION_RETURN_{Name}`

	local Yield = Value.Yield
	local IsFuture = (Yield == "Future")
	local IsPromise = (Yield == "Promise")
	local IsCoroutine = (Yield == "Coroutine")

	if IsFuture and not Options.FutureLibrary then
		error(`Cannot use yield type: "Future", without providing a path to the future library.`)
	end

	if IsPromise and not Options.PromiseLibrary then
		error(`Cannot use yield type: "Promise", without providing a path to the promise library.`)
	end

	local Block = Reliables
	local Channel = Channels.Reliable

	local Index = Channel.Count
	local Queue = `Queue.Reliable[{Index}]`
	local Connection = `Events.Reliable[{Index}]`

	--> Data and return body
	local DataTypes, DataValues, _, DataArguments = "nil", "Value: nil", nil, "Value"
	local ReturnTypes, ReturnValues, _, ReturnArguments = "nil", "ReturnValue: nil", nil, "ReturnValue"

	if Value.Data then
		DataTypes, DataValues, _, DataArguments = Generators.LuauType(Value.Data :: Type, true)
	end

	if Value.Return then
		ReturnTypes, ReturnValues, _, ReturnArguments = Generators.LuauType(Value.Return :: Type, true, "Return")
	end

	do
		local DataRead, DataWrite = Generators.Event(Value.Data :: Type, Index, DataIdentifier, "Data")
		local ReturnRead, ReturnWrite = Generators.Event(Value.Return :: Type, Index, ReturnIdentifier, "Return")
		
		if Context == "Client" then
			UserTypes.PushLines(DataWrite, 1, 0)
			UserTypes.PushLines(ReturnRead, 1, 0)
		elseif Context == "Server" then
			UserTypes.PushLines(DataRead, 1, 0)
			UserTypes.PushLines(ReturnWrite, 1, 0)
		end
	end

	--> Main
	local Body = Builder.new()
	local Indent = Util.GetScopeIndent(Scope)

	Noop.Push(`{Name} = \{`, 0, Indent)
	Body.Push(`{Name} = \{`, 0, Indent)

	--> Create queue and event branch
	Events.Push(`{Queue} = table.create(256)`)
	Block = (Channel.Listening == false)
		and Block:Compare("Index", Index, "Equals")
		or Block:Branch("Conditional", "Index", Index, "Equals")
	
	--> Update event block to branch block
	Reliables = Block

	if Context == "Server" then
		--> Data recieve body
		Types.u8.Read("InvocationIdentifier", Block)
		Block:Line(`local {DataValues} = {Util.GetPath(DataIdentifier, false, Scope)}()`)
		:Compare(Connection, "nil", "Not")
			:Line(`{Connection}(Player, {DataArguments}, InvocationIdentifier)`)
		:Branch("Default")
			:Compare(`#{Queue}`, "256", "Greater")
				:Line(`warn("[Blink]: Event queue of \\"{Name}\\" exceeded 256, did you forget to implement a listener?")`)
			:End()
			:Line(`table.insert({Queue}, \{Player, {DataArguments}, InvocationIdentifier\} :: \{any\})`)
		:End()

		--> Data listener body
		local FlushQueue = Blocks.Function("", "", "()")
			:Line(`local EventQueue = {Queue} or \{\}`)
			:Line(`{Queue} = nil`)
			:Iterator("Index", "Arguments", "EventQueue")
				:Line(`{Connection}(table.unpack(Arguments))`)
			:End()
		:End()
		:Wrap("task.spawn(", ")")

		local Serialize = Blocks.Function("", "")
			:Line(`{ReturnArguments} = Listener(Player, {DataArguments})`)
		:End()
		:Wrap("local Success, Error = pcall(", ")")

		local TrueListener = Blocks.Function(Connection, `Player: Player, {DataValues}, InvocationIdentifier: number`, "()", true)
			:Line(`local {ReturnValues};`)
			:Lines(Serialize.Content, 1)
			:Line("Load(PlayersMap[Player])")
			:Compare("Success", "true", "Not")
				:Line("local Position = Allocate(3)")
				:Line(`buffer.writeu8(SendBuffer, Position, {Index})`)
				:Line(`buffer.writeu8(SendBuffer, Position + 1, InvocationIdentifier)`)
				:Line(`buffer.writeu8(SendBuffer, Position + 2, 0)`)
				:Line(`warn(\`"{Name}" encountered an error, \{Error\}\`)`)
			:Branch("Default")
				:Line(`{Util.GetPath(ReturnIdentifier, true, Scope)}({ReturnArguments}, InvocationIdentifier)`)
			:End()
			:Line("PlayersMap[Player] = Save()")
		:End()

		local Listener = Blocks.Function(Casing.On, `Listener: (Player, {DataTypes}) -> ({ReturnTypes})`, "()", true)
			:Lines(TrueListener.Content, 1)
			:Lines(FlushQueue.Content, 1)
		:End()

		Noop.Push(`{Casing.On} = NOOP`, 0, Indent + 1)
		Body.PushLines(Listener.Content, 0, 2)
	else
		--> Return recieve body
		local Deserialize = Blocks.Function("", "")
			:Return(`{Util.GetPath(ReturnIdentifier, false, Scope)}()`)
		:End()
		:Wrap(`local Success, {ReturnArguments} = pcall(`, ")")

		Types.u8.Read("InvocationIdentifier", Block)
		Block:Compare("Calls[InvocationIdentifier]", "nil", "Not")
			:Lines(Deserialize.Content, Block.Indent + 1)
			:Line(`task.spawn(Calls[InvocationIdentifier], Success, {ReturnArguments})`)
			:Line("Calls[InvocationIdentifier] = nil")
		:End()

		--> Function listener body
		local Exhaust = Blocks.Block()
			:Compare("Calls[InvocationIdentifier]", "nil", "Not")
				--> Fail instead of closing/cancelling the thread
				:Line("Invocations -= 1")
				:Line("error(\"More than 256 calls are awaiting a response, this packet has been dropped.\")")
			:End()
		.Content

		local Error = `"There was an exception while processing \\"{Name}\\"."`
		local Contents = Blocks.Block()
			:Line("local InvocationIdentifier = Invoke()")
			:Lines(Exhaust)
			:Line(`{Util.GetPath(DataIdentifier, true, Scope)}({DataArguments}, InvocationIdentifier)`)
			:Line("Calls[InvocationIdentifier] = coroutine.running()")
			:Line(`local Success, {ReturnValues} = coroutine.yield()`)
			:Compare("Success", "true", "Not")
				:Line(`error({Error})`)
			:End()
		:Return(ReturnArguments).Content

		local Invoke;
		if IsFuture then
			local Wrapper = Blocks.Function("", "")
				:Lines(Contents)
			:End()
			:Wrap("return Future.Try(", ")")

			Invoke = Blocks.Function(Casing.Invoke, DataValues, `Future.Future<boolean, {ReturnTypes}>`, true)
			Invoke:Lines(Wrapper.Content, 1)
		elseif IsPromise then
			local OnCancel = Blocks.Function("", "")
				:Line("Calls[InvocationIdentifier] = nil")
			:End()
			:Wrap("OnCancel(", ")")

			local Promise = Blocks.Function("", "Resolve, Reject, OnCancel")
				:Line("local InvocationIdentifier = Invoke()")
				:Lines(Exhaust)
				:Line(`{Util.GetPath(DataIdentifier, true, Scope)}({DataArguments}, InvocationIdentifier)`)
				:Line("Calls[InvocationIdentifier] = coroutine.running()")
				:Lines(OnCancel.Content, 1)
				:Line(`local Success, {ReturnValues} = coroutine.yield()`)
				:Compare("Success", "true", "Not")
					:Line(`Reject({Error})`)
					:Return("")
				:End()
				:Line(`Resolve({ReturnArguments})`)
			:End()
			:Wrap(`return Promise.new(`, ")")

			Invoke = Blocks.Function(Casing.Invoke, DataValues, `any`, true)
			Invoke:Lines(Promise.Content, 1)
		else
			Invoke = Blocks.Function(Casing.Invoke, DataValues, `({ReturnTypes})`, true)
			Invoke:Lines(Contents, 0)
		end

		Invoke:End()
		Noop.Push(`{Casing.Invoke} = NOOP`, 0, Indent + 1)
		Body.PushLines(Invoke.Content, 0, Indent + 1)
	end

	Channel.Count += 1
	Channel.Listening = true

	Noop.Push(`\},`, 0, Indent)
	Body.Push(`\},`, 0, Indent)
	Return.PushLines(Body.DumpLines(), 0)
end

function Declarations.Array(Declaration: Parser.Array, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Of = Value.Of
	local Range = Value.Range :: NumberRange

	Read:Comment("START ARRAY")
	Write:Comment("START ARRAY")

	local Lower = Range.Min
	local Upper = Range.Max

	local Iterator = `Item_{Read.Indent}`
	local IsVariableSize = (Lower ~= Upper)

	--> Length
	if IsVariableSize then
		local LengthType = Prefabs.GetTypeToUse(Upper)
		LengthType.Read("Length", Read)
		local Assert = Prefabs.Asserts.number("Length", Lower, Upper)

		Read:Line(Assert.Lower)
		Read:Line(Assert.Upper)
		LengthType.Write(`#{Variable}`, Write)
	else
		Read:Line(`local Length = {Upper}`)
	end

	--> Array
	Read:Line(`{Read:Declare(Variable)} = table.create(Length)`)

	--> Body
	Read = Read:Loop("Index = 1", "Length")
	Write = Write:Loop("Index = 1", IsVariableSize and `#{Variable}` or Upper)

	Write:Line(`local {Iterator} = {Variable}[Index]`)
	Generators.UserType(Of, Read, Write, Iterator)

	Read:Line(`table.insert({Variable}, {Iterator})`)

	--> End
	Read = Read:End()
	Write = Write:End()

	Read:Comment("END ARRAY")
	Write:Comment("END ARRAY")
end

function Declarations.Optional(Declaration: Parser.Optional, Read: Blocks.Block, Write: Blocks.Block, Variable: string, IsInstance: boolean)
	Read:Declare(Variable, true)

	if IsInstance then
		Read = Read:Compare("typeof(RecieveInstances[RecieveInstanceCursor])", "\"Instance\"", "Equals")
	else
		Types.u8.Write(`{Variable} ~= nil and 1 or 0`, Write)
		Read = Read:Compare(`buffer.readu8(RecieveBuffer, {Read:Read(1)})`, "1", "Equals")
		Write = Write:Compare(Variable, "nil", "Not")
	end

	Generators.UserType(Declaration.Value.Of, Read, Write, Variable)
	Read:End()

	if not IsInstance then
		Write:End()
	end
end

--> Generator functions
function Generators.UserType(Declaration: Type, Read: Blocks.Block, Write: Blocks.Block, Variable: string?)
	local Name = Declaration.Name
	local Variable = Variable or "Value"
	local IsInstance = false

	if Declaration.Type == "Primitive" then
		local Tokens = (Declaration :: Parser.Primitive).Tokens
		local Primitive = Tokens.Primitive.Value
		IsInstance = (Primitive == "Instance")
	end

	if not _G.BUNDLED then
		Read:Comment(`{Variable}: {Name}`)
		Write:Comment(`{Variable}: {Name}`)
	end

	--> Instance
	if IsInstance then
		Read:Line("RecieveInstanceCursor += 1")
	end

	if Declaration.Type == "Primitive" then
        Declarations.Primitive(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "Set" then
		Declarations.Set(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "Map" then
		Declarations.Map(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "Enum" then
		Declarations.Enum(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "Struct" then
		Declarations.Struct(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "Tuple" then
		Declarations.Tuple(Declaration, Read, Write)
	elseif Declaration.Type == "TagEnum" then
		Declarations.TagEnum(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "Array" then
		Declarations.Array(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "Optional" then
		Declarations.Optional(Declaration, Read, Write, Variable, IsInstance)
    end
end

function Generators.LuauType(Declaration: Type, UseTypeAsValue: boolean?, Prefix: string?): (string, string, string, string)
	Prefix = Prefix or ""

	local Type = ""
	local Values = ""
	local Export = Util.GetExportName(Declaration.Name, Scope)
	local Returns = `{Prefix}Value`

	if Declaration.Type == "Primitive" then
		local Tokens = (Declaration :: Parser.Primitive).Tokens
		local Primitive = Primitives[Tokens.Primitive.Value]
		if type(Primitive.Type) == "function" then
			Type = Primitive.Type(Declaration :: Parser.Primitive)
		else
			Type = Primitive.Type
		end
	elseif Declaration.Type == "Set" then
		local Value = (Declaration :: Parser.Set).Value
		local Entries: {string} = {}

		for _, Flag in Value.Values do
			table.insert(Entries, `{FormatKey(Flag)}: boolean,`)
		end

		Type = `\{{table.concat(Entries)}\}`
	elseif Declaration.Type == "Enum" then
		local Value = (Declaration :: Parser.Enum).Value
		Type = `({Util.GenerateEnumLiterals(Value.Values)})`
	elseif Declaration.Type == "TagEnum" then
		local Value = (Declaration :: Parser.TagEnum).Value
		local Literals = {}

		for Index, Variant in Value.Values do
			local TagField = `{FormatKey(Value.Tag)}: "{Variant.Name}"`
			local ValueType = Generators.LuauType(Variant)
			table.insert(Literals, `\{ {TagField},{string.sub(ValueType, 2)}`)
		end

		Type = table.concat(Literals, " | ")
	elseif Declaration.Type == "Map" then
		local MapValue = (Declaration :: Parser.Map).Value
		local Key = Generators.LuauType(MapValue.Values[1])
		local Value = Generators.LuauType(MapValue.Values[2])
		Type = `\{[{Key}]: {Value}\}`
	elseif Declaration.Type == "Struct" then
		local Value = Declaration.Value
		local Fields = {}
		
		for _, Field in Value.Values do
			local Name = Field.Name
			local FieldType = Generators.LuauType(Field)
			table.insert(Fields, `{FormatKey(Name)}: {FieldType}`)
		end

		Type = `\{ {table.concat(Fields, ", ")}\ }`
	elseif Declaration.Type == "Generic" then
		Type = `{Declaration.Value.Generic}`
	elseif Declaration.Type == "Tuple" then
		local Value = (Declaration :: Parser.Tuple).Value
		local TupleValues = Value.Values
		Returns = ""

		local Types = {}
		local Variables = {} 
		local VariableTypes = {}

		for Index, TupleValue in TupleValues do
			local Variable = `{Prefix}Value{Index}`
			local ValueType = Generators.LuauType(TupleValue)
			table.insert(Types, ValueType)
			table.insert(Variables, Variable)
			table.insert(VariableTypes, `{Variable}: {ValueType}`)
		end

		Type = table.concat(Types, ", ")
		Values = table.concat(VariableTypes, ", ")
		Returns = table.concat(Variables, ", ")
	elseif Declaration.Type == "Array" then
		local Value = Declaration.Value
		Type = `\{ {Generators.LuauType(Value.Of)} }`
	elseif Declaration.Type == "Optional" then
		local Value = Declaration.Value
		Type = `({Generators.LuauType(Value.Of)})?`
	end

	local Value = Declaration.Value

	if Value.Parameters then
		local Parameters = {}

		--> Generate luau types for parameters
		for Index, Parameter in Value.Parameters do
			local ParameterType = Generators.LuauType(Parameter)
			table.insert(Parameters, ParameterType)
		end

		--> Wrap in chevrons
		Type = `{Type}<{table.concat(Parameters, ",")}>`
	end

	--> Generalized type generation, works for everything except tuples
	if Declaration.Type ~= "Tuple" then
		Values = `{Prefix}Value: {UseTypeAsValue and Type or Export}`
	end

	return Type, Values, Export, Returns
end

function Generators.Type(Declaration: Type)
	local Value = Declaration.Value
	local Type, _, Export = Generators.LuauType(Declaration)

	local Generics = ""
	if Value.Generics then
		local Types = {}
		for _, Generic in Value.Generics.List do
			table.insert(Types, Generic)
		end

		Generics = `<{table.concat(Types, ",")}>`
	end

	--> Write luau export
	LuauTypes.PushMultiline(`export type {Export}{Generics} = {Type}`, 1, 0)
end

function Generators.Export(Declaration: Type)
	local Name = Declaration.Name
	local _, Values, Export, Returns = Generators.LuauType(Declaration)

	local Read = Blocks.Function(Casing.Read, "Buffer: buffer", `({Export})`, true)
	local Write = Blocks.Function(Casing.Write, `{Values}`, `(buffer)`, true)

	local Body = Builder.new()
	local Indent = Util.GetScopeIndent(Scope)
	Body.Push(`{Name} = \{`, 0, Indent)

	--> Overwrite buffer
	Read:Comment("Buffer overwrite")
	Write:Comment("Buffer overwrite")

	Read:Lines({
		"local PreviousCursor = RecieveCursor\n",
		"local PreviousBuffer = RecieveBuffer\n",
		"local PreviousInstanceCursor = RecieveInstanceCursor\n",
		"RecieveCursor = 0\n",
		"RecieveBuffer = Buffer\n",
	}, 1)

	Write:Lines({
		"local Previous = Save()\n",
		"Load()\n",
	}, 1)

	Read:Advance(#Read.Content - 1)
	Write:Advance(#Write.Content - 1)

	--> Write to buffer
	Read:Comment("Buffer read")
	Write:Comment("Buffer write")

	Generators.UserType(Declaration, Read, Write)

	--> Restore buffer
	Read:Comment("Buffer restore")
	Write:Comment("Buffer restore")
	
	Read:Lines({
		"RecieveCursor = PreviousCursor\n",
		"RecieveBuffer = PreviousBuffer\n",
		"RecieveInstanceCursor = PreviousInstanceCursor\n",
	}, 1)
	
	--> Trim buffer
	Write:Line("local Result = buffer.create(SendCursor)")
	Write:Line("buffer.copy(Result, 0, SendBuffer, 0, SendCursor)")

	Write:Line(`Load(Previous)`)

	--> End export
	Read:Return(Returns)
	Write:Return("Result")
	
	Read:End():Wrap("", ",")
	Write:End()

	Body.PushLines(Read.Content, 0, Indent + 1)
	Body.PushLines(Write.Content, 0, Indent + 1)
	Body.Push(`\},`, 0, Indent)

	local BodyLines = Body.DumpLines()

	Noop.PushLines(table.clone(BodyLines), 0, 0)
	Return.PushLines(BodyLines, 0, 0)
end

function Generators.Event(Data: Type?, Index: number, Identifier: string, Function: ("Data" | "Return")?): ({string}, {string})
	local Type, Values, _, Returns = "nil", "Value: nil", nil, "nil"
	if Data then
		Type, Values, _, Returns = Generators.LuauType(Data, true)
	end

	local Arguments = `{Values}{Function and ", InvocationIdentifier: number" or ""}`
	local Read = Blocks.Function(Util.GetPath(Identifier, false, Scope), "", `({Type})`, false, true)
	local Write = Blocks.Function(Util.GetPath(Identifier, true, Scope), Arguments, "()", false, true)

	if not _G.BUNDLED then
		Write:Comment(`{Identifier} ({Index})`)
	end

	Types.u8.Write(Index, Write)
	if Function then
		Types.u8.Write("InvocationIdentifier", Write)
		if Function == "Return" then
			Types.u8.Write("1", Write)
			Types.u8.Read("Success", Read)
			Read:Compare("Success", "1", "Not")
				:Line("error(\"Server encountered an error.\")")
			:End()
		end
	end

	if Data then
		Generators.UserType(Data, Read, Write)
	end

	return Read:Return(Returns):End().Content, Write:End().Content
end

function Generators.Scope(Declaration: Parser.ScopeNode)
	local Name = Declaration.Name
	local Value = Declaration.Value

	local Parent = Scope
	local NewScope = Value.Scope

	local Path = Util.GetScopePrefix(NewScope, true, Scope)
	local Indent = (#string.split(Path, ".") - 1)
	Path = string.sub(Path, 1, #Path - 1)

	Scope = NewScope
	Noop.Push(`{Name} = \{`, 0, Indent)
	Return.Push(`{Name} = \{`, 0, Indent)

	Generators.AbstractSyntaxTree(Value.Values)

	Noop.Push(`},`, 0, Indent)
	Return.Push(`},`, 0, Indent)
	Scope = Parent
end

function Generators.AbstractSyntaxTree(Tree: {Parser.Declaration})
	for Index, Declaration in Tree do
		if Context == "Shared" and IGNORED_TYPES_IN_SHARED[Declaration.Type] then
			continue
		end

		if Declaration.Type == "Scope" then
			Generators.Scope(Declaration :: Parser.ScopeNode)
		elseif Declaration.Type == "Event" then
			Declarations.Event(Declaration :: Parser.Event)
		elseif Declaration.Type == "Function" then
			Declarations.Function(Declaration :: Parser.Function)
		else
			if Declaration.Value.Export then
				Generators.Export(Declaration :: Type)
			end

			Generators.Type(Declaration :: Type)
		end
	end
end

local Generator = {}

function Generator.Reset()
	--> Setup new builders
	Noop = Builder.new()
	Events = Builder.new()
    UserTypes = Builder.new()
    LuauTypes = Builder.new()
	Return = Builder.new()

	--> Reset channels
	Channels.Reliable.Count = 0
	Channels.Unreliable.Count = 0
	Channels.Reliable.Listening = false
	Channels.Unreliable.Listening = false
end

function Generator.Generate(FileContext: Context, AbstractSyntaxTree: Parser.Body): string
    local Imports = Builder.new()
	
	Generator.Reset()
	Context = FileContext
	Options = AbstractSyntaxTree.Value.Options
	Casing = Settings.GetCasing((Options.Casing :: Settings.Case) or "Pascal")

	--> Setup noop
	Noop.Push(`if not RunService:IsRunning() then`)
	Noop.Push(`local NOOP = function() end`, 0, 1)
	Noop.Push(`local Returns = table.freeze(\{`, 0, 1)

	--> Setup remote events
	local Signal = Context == "Client" and "OnClientEvent" or "OnServerEvent"
	local Arguments = (Context == "Server" and "Player: Player, " or "") .. "Buffer: buffer, Instances: {Instance}"

	Reliables = Blocks.Connection(`Reliable.{Signal}`, Arguments)
	Unreliables = Blocks.Connection(`Unreliable.{Signal}`, Arguments)

	Reliables:Lines(EVENT_BODY, 1)
	Unreliables:Lines(EVENT_BODY, 1)

	Reliables = Reliables:While("RecieveCursor < Size")
	Unreliables = Unreliables:While("RecieveCursor < Size")
	Types.u8.Read("Index", Reliables)
	Types.u8.Read("Index", Unreliables)

	--> Import async libraries
	if Options.FutureLibrary then
		Imports.Push(`local Future = require({Options.FutureLibrary})`)
	end

	if Options.PromiseLibrary then
		Imports.Push(`local Promise = require({Options.PromiseLibrary})`)
	end

	--> Replication
	local Replication = Builder.new()
	Return.Push(`{Casing.StepReplication} = StepReplication,`, 1, 1)

	if not Options.ManualReplication then
		if Context == "Server" then
			Replication.Push("RunService.Heartbeat:Connect(StepReplication)")
		elseif Context == "Client" then
			Replication.Push("local Elapsed = 0")
			local Connection = Blocks.Connection("RunService.Heartbeat", "DeltaTime: number")
				:Line("Elapsed += DeltaTime")
				:Compare("Elapsed", "(1 / 61)", "GreaterOrEquals")
					:Line("Elapsed -= (1 / 61)")
					:Line("StepReplication()")
				:End()
			:End()
			Replication.PushLines(Connection.Content)
		end
	end

	--> Parse declarations
	Generators.AbstractSyntaxTree(AbstractSyntaxTree.Value.Declarations)

	--> Generate context source
	local Source = Sources[Context]

	if Channels.Reliable.Listening then
		Reliables = Reliables:End()
	end

	if Channels.Unreliable.Listening then
		Unreliables = Unreliables:End()
	end

	Reliables = Reliables:End():End()
	Unreliables = Unreliables:End():End()

	local Globals: {string} = {}
	if not _G.BUNDLED then
		Globals = table.clone(DEBUG_GLOBALS)
		for Index, Macro in Globals do
			local HasPattern = (string.find(Macro, "%s", 1, true) ~= nil)
			if HasPattern then
				Globals[Index] = string.format(Macro, string.lower(Context))
			end
		end
	end

	Noop.Push(`\})`, 0, 1)
	Noop.Push(`return Returns :: {EVENTS_TYPE}`, 0, 1)
	Noop.Push(`end`, 0, 0)

	Return.PushFront(`\nlocal Returns = table.freeze(\{`)
	Return.Push(`})`)

	local MergedOutput = Table.Merge(
		DIRECTIVES,
		VERSION_HEADER,
		Globals,
		string.split(Source[1], "\r"),
		Imports.DumpLines(),
		string.split(Sources.Base, "\r"),
		Events.DumpLines(),
		LuauTypes.DumpLines(),
		UserTypes.DumpLines(),
		Noop.DumpLines(),
		string.split(Source[2], "\r"),
		Replication.DumpLines(),
		Reliables.Content,
		Unreliables.Content,
		Return.DumpLines(),
		{`type {EVENTS_TYPE} = typeof(Returns)\n`, `return Returns :: {EVENTS_TYPE}`}
	)

	return table.concat(MergedOutput)
end

function Generator.GenerateShared(AbstractSyntaxTree: Parser.Body): string
	Generator.Reset()
	Context = "Shared"
	Options = AbstractSyntaxTree.Value.Options
	Casing = Settings.GetCasing((Options.Casing :: Settings.Case) or "Pascal")

	--> Parse declarations
	Generators.AbstractSyntaxTree(AbstractSyntaxTree.Value.Declarations)

	--> Generate context source
	local Source = Sources[Context]
	local MergedOutput = Table.Merge(
		DIRECTIVES,
		VERSION_HEADER,
		string.split(Source[1], "\r"),
		string.split(Sources.Base, "\r"),
		LuauTypes.DumpLines(),
		{"\n"},
		UserTypes.DumpLines(),
		string.split(Source[2], "\r"),
		{"\n"},
		{`\nreturn \{\n`},
		Return.DumpLines(),
		{"\n}"}
	)

	return table.concat(MergedOutput)
end

function Generator.GenerateTypescript(FileContext: Context, AbstractSyntaxTree: Parser.Body): string
	return GenerateTypescript(FileContext, AbstractSyntaxTree)
end

return Generator